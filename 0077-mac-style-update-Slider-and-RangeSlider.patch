From fb7c372756b0639471595b43c2d385cc7f86e1c2 Mon Sep 17 00:00:00 2001
From: Richard Moe Gustavsen <richard.gustavsen@qt.io>
Date: Fri, 19 Sep 2025 10:47:58 +0200
Subject: [PATCH 077/239] mac style: update Slider and RangeSlider
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

On macOS Tahoe 26, the drawing of a Slider and RangeSlider
using the mac style is broken. Nothing is drawn if we continue to use
[NSView drawRect:], [NSView bitmapImageRepForCachingDisplayInRect:]
or [CALayer renderInContext:] (and similar API) for drawing
those controls, most likely since the handle has a liquid glass effect.

This patch will therefore draw the mentioned controls using QML
instead. The sliders and the switch used to share the same
SwitchHandle.qml for drawing the handle, but their appearance has
changed too much to justify that. So this patch will also add a
new SliderHandle.qml that only Slider and RangeSlider will share.
This handle will also mimic a liquid glass effect when running in
an app with liquid glass enabled.

As it stood, we also used to draw a Slider and a RangeSlider differently
since there is no native RangeSlider in AppKit. To instead keep them
aligned visually, and to also keep the code complexity down, we now
always draw the Slider using QML, even when not running with liquid glass.

Pick-to: 6.9 6.8 6.5
Task-number: QTBUG-138946
Task-number: QTBUG-138942
Change-Id: I21397268d6f62cbc8cd2ca24f81b63e5c80d1815
Reviewed-by: Tor Arne Vestbø <tor.arne.vestbo@qt.io>
(cherry picked from commit 694112fc102e8c2651f2d5b78a9dfa8350e165d5)
---
 src/quickcontrols/macos/RangeSlider.qml       |  66 +++++++----
 src/quickcontrols/macos/Slider.qml            | 110 ++++++++++++++----
 src/quickcontrols/macos/impl/CMakeLists.txt   |   1 +
 src/quickcontrols/macos/impl/SliderHandle.qml | 105 +++++++++++++++++
 4 files changed, 238 insertions(+), 44 deletions(-)
 create mode 100644 src/quickcontrols/macos/impl/SliderHandle.qml

diff --git a/src/quickcontrols/macos/RangeSlider.qml b/src/quickcontrols/macos/RangeSlider.qml
index 897e23eedc..d264326acb 100644
--- a/src/quickcontrols/macos/RangeSlider.qml
+++ b/src/quickcontrols/macos/RangeSlider.qml
@@ -5,6 +5,7 @@ import QtQuick
 import QtQuick.Templates as T
 import QtQuick.Controls.impl
 import QtQuick.Controls.macOS.impl
+import QtQuick.NativeStyle as NativeStyle
 
 T.RangeSlider {
     id: control
@@ -16,30 +17,41 @@ T.RangeSlider {
 
     readonly property bool __notCustomizable: true
 
-    first.handle: SwitchHandle {
-        x: control.leftPadding + Math.round(control.horizontal
-            ? control.first.visualPosition * (control.availableWidth - width)
-            : (control.availableWidth - width) / 2)
-        y: control.topPadding + Math.round(control.horizontal
-            ? (control.availableHeight - height) / 2
-            : control.first.visualPosition * (control.availableHeight - height))
+    first.handle: SliderHandle {
+        x: Math.round(control.horizontal
+            ? control.leftPadding + (control.first.position * (control.availableWidth - width))
+            : (control.width - width) / 2)
+        y: Math.round(control.horizontal
+            ? (control.height - height) / 2
+            : control.leftPadding + (control.availableHeight - height - (control.first.position * (control.availableHeight - height + 4)) + 2))
+        width: NativeStyle.StyleConstants.runningWithLiquidGlass ? (control.horizontal ? 20 : 16) : implicitWidth
+        height: NativeStyle.StyleConstants.runningWithLiquidGlass ? (control.horizontal ? 16 : 20) : implicitHeight
 
         palette: control.palette
-        down: control.first.pressed
-
+        pressed: control.first.pressed
+        progress: control.first.position
+        orientation: control.orientation
+        isRangeSlider: true
+        isLeftHandle: true
         readonly property bool __ignoreNotCustomizable: true
     }
 
-    second.handle: SwitchHandle {
-        x: control.leftPadding + Math.round(control.horizontal
-            ? control.second.visualPosition * (control.availableWidth - width)
-            : (control.availableWidth - width) / 2)
-        y: control.topPadding + Math.round(control.horizontal
-            ? (control.availableHeight - height) / 2
-            : control.second.visualPosition * (control.availableHeight - height))
+    second.handle: SliderHandle {
+        x: Math.round(control.horizontal
+            ? control.leftPadding + (control.second.position * (control.availableWidth - width))
+            : (control.width - width) / 2)
+        y: Math.round(control.horizontal
+            ? (control.height - height) / 2
+            : control.leftPadding + (control.availableHeight - height - (control.second.position * (control.availableHeight - height + 4)) + 2))
+        width: NativeStyle.StyleConstants.runningWithLiquidGlass ? (control.horizontal ? 20 : 16) : implicitWidth
+        height: NativeStyle.StyleConstants.runningWithLiquidGlass ? (control.horizontal ? 16 : 20) : implicitHeight
 
         palette: control.palette
-        down: control.second.pressed
+        pressed: control.second.pressed
+        progress: control.second.position
+        orientation: control.orientation
+        isRangeSlider: true
+        isLeftHandle: false
 
         readonly property bool __ignoreNotCustomizable: true
     }
@@ -86,15 +98,23 @@ T.RangeSlider {
 
         // Progress bar.
         Rectangle {
-            x: control.horizontal ? control.first.position * parent.width + 3 : (parent.width - width) / 2
-            y: control.horizontal ? (parent.height - height) / 2 : control.second.visualPosition * parent.height + 3
+            x: control.horizontal ? control.first.position * parent.width : (parent.width - width) / 2
+            y: control.horizontal ? (parent.height - height) / 2 : control.second.visualPosition * parent.height
             width: control.horizontal
-                ? control.second.position * parent.width - control.first.position * parent.width - parent.barThickness
+                ? control.second.position * parent.width - control.first.position * parent.width
                 : parent.barThickness
             height: control.horizontal
                 ? parent.barThickness
-                : control.second.position * parent.height - control.first.position * parent.height - parent.barThickness
-            color: control.palette.accent
-        }
+                : control.second.position * parent.height - control.first.position * parent.height
+            radius: height / 2
+            color: {
+                const light = Application.styleHints.colorScheme === Qt.Light
+                if (!control.enabled)
+                    return light ? "transparent" : Qt.lighter(control.palette.window, 1.4)
+                if (Application.state !== Qt.ApplicationActive)
+                    return Qt.lighter(control.palette.window, light ? 0.9 : 1.8)
+                return control.palette.accent
+            }
+       }
     }
 }
diff --git a/src/quickcontrols/macos/Slider.qml b/src/quickcontrols/macos/Slider.qml
index 6dd989c13a..df899d9941 100644
--- a/src/quickcontrols/macos/Slider.qml
+++ b/src/quickcontrols/macos/Slider.qml
@@ -2,38 +2,106 @@
 // SPDX-License-Identifier: LicenseRef-Qt-Commercial OR LGPL-3.0-only OR GPL-2.0-only OR GPL-3.0-only
 
 import QtQuick
+import QtQuick.Controls.impl
+import QtQuick.Controls.macOS.impl
 import QtQuick.NativeStyle as NativeStyle
+import QtQuick.Templates as T
 
-NativeStyle.DefaultSlider {
+T.Slider {
     id: control
     readonly property Item __focusFrameTarget: handle
     readonly property Item __focusFrameStyleItem: handle
 
-    background: NativeStyle.Slider {
-        control: control
-        subControl: NativeStyle.Slider.Groove | NativeStyle.Slider.Handle
-        // We normally cannot use a nine patch image for the
-        // groove if we draw tickmarks (since then the scaling
-        // would scale the tickmarks too). The groove might
-        // also use a different background color before, and
-        // after, the handle.
-        useNinePatchImage: false
+    implicitWidth: Math.max(implicitBackgroundWidth + leftInset + rightInset,
+                            implicitHandleWidth + leftPadding + rightPadding)
+    implicitHeight: Math.max(implicitBackgroundHeight + topInset + bottomInset,
+                             implicitHandleHeight + topPadding + bottomPadding)
+
+    readonly property bool __notCustomizable: true
+
+    handle: SliderHandle {
+        x: Math.round(control.horizontal
+            ? control.leftPadding + (control.position * (control.availableWidth - width))
+            : (control.width - width) / 2)
+        y: Math.round(control.horizontal
+            ? (control.height - height) / 2
+            : control.leftPadding + (control.availableHeight - height - (control.position * (control.availableHeight - height + 4)) + 2))
+        width: NativeStyle.StyleConstants.runningWithLiquidGlass ? (control.horizontal ? 20 : 16) : implicitWidth
+        height: NativeStyle.StyleConstants.runningWithLiquidGlass ? (control.horizontal ? 16 : 20) : implicitHeight
+
+        palette: control.palette
+        pressed: control.pressed
+        progress: control.position
+        orientation: control.orientation
+        isLeftHandle: true
+        isRangeSlider: false
 
         readonly property bool __ignoreNotCustomizable: true
     }
 
-    handle: NativeStyle.Slider {
-        // The handle is hidden, since it will be drawn as a part
-        // of the background. But will still needs it to be here so
-        // that we can place the focus rect correctly.
-        visible: false
-
-        control: control
-        subControl: NativeStyle.Slider.Handle
-        x: control.leftPadding + (control.horizontal ? control.visualPosition * (control.availableWidth - width) : (control.availableWidth - width) / 2)
-        y: control.topPadding + (control.horizontal ? (control.availableHeight - height) / 2 : control.visualPosition * (control.availableHeight - height))
-        useNinePatchImage: false
+    background: Item {
+        implicitWidth: control.horizontal ? 90 : 24
+        implicitHeight: control.horizontal ? 24 : 90
 
         readonly property bool __ignoreNotCustomizable: true
+        readonly property int barThickness: NativeStyle.StyleConstants.runningWithLiquidGlass ? 6 : 4
+
+        // Groove background.
+        Rectangle {
+            x: control.horizontal ? 0 : (parent.width - width) / 2
+            y: control.horizontal ? (parent.height - height) / 2 : 0
+            width: control.horizontal ? parent.width : parent.barThickness
+            height: control.horizontal ? parent.barThickness : parent.height
+            radius: height / 2
+            color: control.palette.window
+
+            Rectangle {
+                width: parent.width
+                height: parent.height
+                radius: parent.radius
+                // No border in dark mode, instead we fill.
+                color: Application.styleHints.colorScheme === Qt.Light
+                    ? "transparent" : Qt.lighter(control.palette.window, 1.4)
+                border.color: Application.styleHints.colorScheme === Qt.Light
+                    ? Qt.darker(control.palette.window, 1.06)
+                    : "transparent"
+
+                Rectangle {
+                    x: 1
+                    y: 1
+                    width: parent.width - 2
+                    height: parent.height - 2
+                    radius: parent.radius
+                    color: "transparent"
+                    border.color: Qt.darker(control.palette.window, 1.05)
+                    visible: Application.styleHints.colorScheme === Qt.Light
+                }
+            }
+        }
+
+        // Progress bar.
+        Rectangle {
+            x: control.leftPadding + Math.round(control.horizontal
+                ? 0 : (parent.width - width) / 2)
+            y: control.topPadding + Math.round(control.horizontal
+                ? (control.height - height) / 2
+                : control.height - (control.position * control.height))
+            width: control.horizontal
+                ? control.position * control.width
+                : parent.barThickness
+            height: control.horizontal
+                ? parent.barThickness
+                : control.position * control.height
+            radius: height / 2
+            color: {
+                const light = Application.styleHints.colorScheme === Qt.Light
+                if (!control.enabled)
+                    return light ? "transparent" : Qt.lighter(control.palette.window, 1.4)
+                if (Application.state !== Qt.ApplicationActive)
+                    return Qt.lighter(control.palette.window, light ? 0.9 : 1.8)
+                return control.palette.accent
+            }
+        }
     }
+
 }
diff --git a/src/quickcontrols/macos/impl/CMakeLists.txt b/src/quickcontrols/macos/impl/CMakeLists.txt
index 1ae0e563df..86d2aa12d8 100644
--- a/src/quickcontrols/macos/impl/CMakeLists.txt
+++ b/src/quickcontrols/macos/impl/CMakeLists.txt
@@ -3,6 +3,7 @@
 
 set(qml_files
     "CheckIndicator.qml"
+    "SliderHandle.qml"
     "SwitchHandle.qml"
     "SwitchIndicator.qml"
 )
diff --git a/src/quickcontrols/macos/impl/SliderHandle.qml b/src/quickcontrols/macos/impl/SliderHandle.qml
new file mode 100644
index 0000000000..d8ab90affb
--- /dev/null
+++ b/src/quickcontrols/macos/impl/SliderHandle.qml
@@ -0,0 +1,105 @@
+// Copyright (C) 2025 The Qt Company Ltd.
+// SPDX-License-Identifier: LicenseRef-Qt-Commercial OR LGPL-3.0-only OR GPL-2.0-only OR GPL-3.0-only
+
+import QtQuick
+import QtQuick.Templates as T
+import QtQuick.NativeStyle as NativeStyle
+import QtQuick.Shapes
+import QtQuick.Effects
+
+Item {
+    id: handle
+    implicitWidth: 22
+    implicitHeight: 22
+
+    required property bool pressed
+    required property real progress
+    required property int orientation
+    required property bool isRangeSlider
+    required property bool isLeftHandle
+
+    readonly property color handleColor: Application.styleHints.colorScheme === Qt.Light ? "white" : "#cccdce"
+    readonly property color handlePressedColor1: Application.styleHints.colorScheme === Qt.Light
+                                                ? Qt.alpha("white", 0.4) : Qt.alpha("white", 0.2)
+    readonly property color handlePressedColor2: Application.styleHints.colorScheme === Qt.Light
+                                                ? Qt.alpha("black", 0.07) : Qt.alpha("black", 0.2)
+    readonly property real refraction1: Application.styleHints.colorScheme === Qt.Light ? 0.07 : 0.1
+    readonly property real refraction2: Application.styleHints.colorScheme === Qt.Light ? 0.04 : 0.06
+
+    Loader {
+        active: NativeStyle.StyleConstants.runningWithLiquidGlass
+        x: (parent.width - width) / 2
+        y: (parent.height - height) / 2
+        width: parent.width + (parent.pressed ? 5 : 0)
+        height: parent.height + (parent.pressed ? 5 : 0)
+        rotation: (!isRangeSlider && orientation === Qt.Vertical)
+                || (isRangeSlider && isLeftHandle && orientation === Qt.Horizontal)
+                || (isRangeSlider && !isLeftHandle && orientation === Qt.Vertical)
+                  ? 180 : 0
+        readonly property real refractionStrength: (isRangeSlider && isLeftHandle) ? 1 - handle.progress : handle.progress
+        Behavior on width { NumberAnimation { duration: 100 } }
+        Behavior on height { NumberAnimation { duration: 100 } }
+        sourceComponent: Rectangle {
+            radius: width / 2
+            gradient: RadialGradient {
+                orientation: handle.orientation
+                GradientStop { position: 0.0; color: pressed ? Qt.alpha(palette.accent, refractionStrength === 0 ? 0.1 : 1) : handleColor }
+                GradientStop { position: refraction1 * refractionStrength; color: pressed ? Qt.alpha(palette.accent, refractionStrength === 0 ? 0.1 : 1) : handleColor }
+                GradientStop { position: (refraction1 * refractionStrength) + 0.1; color: pressed ? handlePressedColor1 : handleColor }
+                GradientStop { position: 1 - (refraction2 * refractionStrength) - 0.1; color: pressed ? handlePressedColor2 : handleColor }
+                GradientStop { position: 1 - (refraction2 * refractionStrength); color: pressed ? palette.accent : handleColor }
+                GradientStop { position: 1.0; color: pressed ? Qt.alpha(palette.accent, handle.progress === 0 ? 0.1 : 1) : handleColor }
+            }
+
+            border.color: Application.styleHints.accessibility.contrastPreference === Qt.HighContrast
+                          ? Application.styleHints.colorScheme === Qt.Light ? "#b3000000" : "#b3ffffff"
+                            : Application.styleHints.colorScheme === Qt.Light
+                                ? Qt.alpha("white", 0.5) : Qt.alpha("black", 0.5)
+            border.width: Application.styleHints.accessibility.contrastPreference === Qt.HighContrast || pressed ? 1 : 0
+
+            Behavior on color { ColorAnimation { duration: 100 } }
+
+            layer.enabled: Application.styleHints.accessibility.contrastPreference !== Qt.HighContrast
+            layer.effect: MultiEffect {
+                shadowEnabled: true
+                blurMax: 10
+                shadowBlur: 1
+                shadowScale: 1.3
+                shadowOpacity: 0.05
+            }
+        }
+    }
+
+    Loader {
+        active: !NativeStyle.StyleConstants.runningWithLiquidGlass
+        x: (parent.width - width) / 2
+        y: (parent.height - height) / 2
+        width: parent.width
+        height: parent.height
+        sourceComponent: Rectangle {
+            radius: width / 2
+            color: {
+                const light = Application.styleHints.colorScheme === Qt.Light
+                if (!control.enabled)
+                    return light ? palette.base : "#4a4e52";
+                if (Application.styleHints.colorScheme === Qt.Light)
+                    return Qt.darker(handleColor, handle.pressed ? 1.05 : 1)
+                else
+                    return Qt.lighter(handleColor, handle.pressed ? 1.05 : 1)
+            }
+            border.color: Application.styleHints.accessibility.contrastPreference === Qt.HighContrast
+                          ? Application.styleHints.colorScheme === Qt.Light ? "#b3000000" : "#b3ffffff"
+            : "transparent"
+            border.width: 1
+
+            layer.enabled: Application.styleHints.accessibility.contrastPreference !== Qt.HighContrast
+            layer.effect: MultiEffect {
+                shadowEnabled: true
+                blurMax: 10
+                shadowBlur: 0.2
+                shadowScale: 0.92
+                shadowOpacity: 1
+            }
+        }
+    }
+}
-- 
2.51.2

