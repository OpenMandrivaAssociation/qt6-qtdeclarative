From 97d40d7a5cf44be48b6011553856020e350f1f15 Mon Sep 17 00:00:00 2001
From: Shawn Rutledge <shawn.rutledge@qt.io>
Date: Wed, 10 Sep 2025 20:44:33 +0200
Subject: [PATCH 093/239] deliverHoverEventRecursive(): don't crash if a child
 disappears

Hover event delivery could result in deletion of a child item.
If this happens, just stop and wait until the next delivery, to avoid
dereferencing a dangling pointer.

In QTBUG-139561 an item's layer.enabled is bound to MouseArea's
containsMouse.  When the mouse enters, a QQuickShaderEffectSource is
created, and destroyed again when it exits; but at that time, the
QQuickShaderEffectSource is in the QList that
deliverHoverEventRecursive() is iterating. We must not try to visit it
(or access its itemPrivate, call isVisible(), etc.)  after it's
destroyed; but tracking each item's lifetime in this high-frequency
function would be expensive. So we have to hope that aborting delivery
here will not result in chronic hover failure in some other case; but so
far it seems this crash is very rare. Usually delivery of a hover event
to one item does not result in destruction of a sibling item.

Done-with: Lu YaNing <luyaning@uniontech.com>
Fixes: QTBUG-139561
Pick-to: 6.9 6.8
Change-Id: I0f761474ee07c9d6dd669702aff6905023242ac3
Reviewed-by: Santhosh Kumar <santhosh.kumar.selvaraj@qt.io>
Reviewed-by: Richard Moe Gustavsen <richard.gustavsen@qt.io>
Reviewed-by: YaNing Lu <luyaning@uniontech.com>
(cherry picked from commit 75914914a4f69aed0e868aeb5ddb1ae4766798b9)
Reviewed-by: Qt Cherry-pick Bot <cherrypick_bot@qt-project.org>
---
 src/quick/util/qquickdeliveryagent.cpp        |  6 ++++
 .../data/layerEnabledHoverCrash.qml           | 34 +++++++++++++++++++
 .../tst_qquickdeliveryagent.cpp               | 30 ++++++++++++++++
 3 files changed, 70 insertions(+)
 create mode 100644 tests/auto/quick/qquickdeliveryagent/data/layerEnabledHoverCrash.qml

diff --git a/src/quick/util/qquickdeliveryagent.cpp b/src/quick/util/qquickdeliveryagent.cpp
index 8242e1f867..4c85f370ee 100644
--- a/src/quick/util/qquickdeliveryagent.cpp
+++ b/src/quick/util/qquickdeliveryagent.cpp
@@ -1199,8 +1199,14 @@ bool QQuickDeliveryAgentPrivate::deliverHoverEventRecursive(
 
     const QQuickItemPrivate *itemPrivate = QQuickItemPrivate::get(item);
     const QList<QQuickItem *> children = itemPrivate->paintOrderChildItems();
+    const bool hadChildrenChanged = itemPrivate->dirtyAttributes & QQuickItemPrivate::ChildrenChanged;
 
     for (int ii = children.size() - 1; ii >= 0; --ii) {
+        // If the children had not changed before we started the loop, but now they have changed,
+        // stop looping to avoid potentially dereferencing a dangling pointer.
+        // This is unusual, and hover delivery occurs frequently anyway, so just wait until next time.
+        if (!hadChildrenChanged && Q_UNLIKELY(itemPrivate->dirtyAttributes & QQuickItemPrivate::ChildrenChanged))
+            break;
         QQuickItem *child = children.at(ii);
         const QQuickItemPrivate *childPrivate = QQuickItemPrivate::get(child);
 
diff --git a/tests/auto/quick/qquickdeliveryagent/data/layerEnabledHoverCrash.qml b/tests/auto/quick/qquickdeliveryagent/data/layerEnabledHoverCrash.qml
new file mode 100644
index 0000000000..6dd367d7f6
--- /dev/null
+++ b/tests/auto/quick/qquickdeliveryagent/data/layerEnabledHoverCrash.qml
@@ -0,0 +1,34 @@
+import QtQuick
+
+// Test case for QTBUG-139561: crash in deliverHoverEventRecursive
+// when layer.enabled is bound to containsMouse during hover processing
+Item {
+    id: root
+    width: 400
+    height: 300
+
+    Rectangle {
+        id: testRect
+        objectName: "testRect"
+        x: 100
+        y: 100
+        width: 200
+        height: 100
+        color: mouseArea.containsMouse ? "wheat" : "lightSteelBlue"
+
+        // This binding causes the crash - layer changes during hover processing
+        layer.enabled: mouseArea.containsMouse
+        MouseArea {
+            id: mouseArea
+            objectName: "testMouseArea"
+            anchors.fill: parent
+            hoverEnabled: true
+        }
+
+        Text {
+            anchors.centerIn: parent
+            text: "Hover me!"
+            color: "white"
+        }
+    }
+}
diff --git a/tests/auto/quick/qquickdeliveryagent/tst_qquickdeliveryagent.cpp b/tests/auto/quick/qquickdeliveryagent/tst_qquickdeliveryagent.cpp
index d012bac274..e6a2c48ffc 100644
--- a/tests/auto/quick/qquickdeliveryagent/tst_qquickdeliveryagent.cpp
+++ b/tests/auto/quick/qquickdeliveryagent/tst_qquickdeliveryagent.cpp
@@ -19,6 +19,7 @@
 #include <QtQuick/private/qquickshadereffectsource_p.h>
 #include <QtQuick/private/qquicktaphandler_p.h>
 #include <QtQuick/private/qquickwindow_p.h>
+#include <QtQuick/private/qquickitem_p.h>
 #include <QtQuickTest/quicktest.h>
 #include <QtQuickTestUtils/private/qmlutils_p.h>
 #include <QtQuickTestUtils/private/visualtestutils_p.h>
@@ -154,6 +155,7 @@ private slots:
     void deleteTargetOnPress();
     void compoundControlsFocusInSubscene();
     void hoverEventGlobalPosition();
+    void layerEnabledHoverCrash();
 
 private:
     std::unique_ptr<QPointingDevice> touchscreen{QTest::createTouchDevice()};
@@ -709,6 +711,34 @@ void tst_qquickdeliveryagent::hoverEventGlobalPosition()
     QCOMPARE(child.globalHoverPosition, child.globalMousePosition);
 }
 
+void tst_qquickdeliveryagent::layerEnabledHoverCrash() // QTBUG-139561
+{
+    QQuickView window;
+    QVERIFY(QQuickTest::showView(window, testFileUrl("layerEnabledHoverCrash.qml")));
+    QSignalSpy swapSpy(&window, &QQuickView::frameSwapped);
+    QQuickItem *testRect = window.rootObject()->findChild<QQuickRectangle*>();
+    QVERIFY(testRect);
+    QQuickMouseArea *mouseArea = window.rootObject()->findChild<QQuickMouseArea*>();
+    QVERIFY(mouseArea);
+    QVERIFY(mouseArea->hoverEnabled());
+    QQuickItemLayer *layer = qvariant_cast<QQuickItemLayer*>(testRect->property("layer"));
+    QVERIFY(layer);
+
+    for (int i = 0; i < 8; ++i) {
+        swapSpy.clear();
+        QTest::mouseMove(&window, QPoint(150, 130));
+        QTRY_COMPARE_GE(swapSpy.size(), 1);
+        QCOMPARE(mouseArea->hovered(), true);
+        QCOMPARE(layer->enabled(), true);
+        QTest::mouseMove(&window, QPoint(10, 10));
+        // hover delivery is frame-synchronous, so wait for rendering to ensure it has a chance to crash :-/
+        QTRY_COMPARE_GE(swapSpy.size(), 2);
+        QCOMPARE(mouseArea->hovered(), false);
+        QCOMPARE(layer->enabled(), false);
+        QTest::qWait(50); // visually verify that it gets un-hovered
+    }
+}
+
 QTEST_MAIN(tst_qquickdeliveryagent)
 
 #include "tst_qquickdeliveryagent.moc"
-- 
2.51.2

