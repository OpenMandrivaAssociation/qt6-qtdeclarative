From 7ffd14c85083d2f9bb40c7c0787aaf85f4b9e2ba Mon Sep 17 00:00:00 2001
From: Fabian Kosmale <fabian.kosmale@qt.io>
Date: Mon, 25 Nov 2024 15:57:21 +0100
Subject: [PATCH 171/239] Fix writing undefined via QQmlProperty

Just as with QMetaProperty::write, writing an invalid QVariant should
trigger a RESET function if it exists.
This not only helps with consistency, but will be needed to correctly
handle writes of initial properties when doing more work via
QQmlProperty.

Task-number: QTBUG-138825
Change-Id: I77058d292bdea34c0b500e6b61b29bca67ff8d99
Reviewed-by: Ulf Hermann <ulf.hermann@qt.io>
(cherry picked from commit d231bd6f735bd8f473bc29079d4608660aaca98e)
Reviewed-by: Qt Cherry-pick Bot <cherrypick_bot@qt-project.org>
---
 src/qml/qml/qqmlproperty.cpp                  |  5 +++
 .../qml/qqmlcomponent/tst_qqmlcomponent.cpp   | 36 +++++++++++++++++++
 2 files changed, 41 insertions(+)

diff --git a/src/qml/qml/qqmlproperty.cpp b/src/qml/qml/qqmlproperty.cpp
index e922cb63c8..7bf74d4f42 100644
--- a/src/qml/qml/qqmlproperty.cpp
+++ b/src/qml/qml/qqmlproperty.cpp
@@ -1846,6 +1846,11 @@ bool QQmlPropertyPrivate::write(
     } else {
         Q_ASSERT(variantMetaType != propertyMetaType);
 
+        if (property.isResettable() && !value.isValid()) {
+            property.resetProperty(object, flags);
+            return true;
+        }
+
         bool ok = false;
         QVariant v;
         if (variantMetaType == QMetaType::fromType<QString>())
diff --git a/tests/auto/qml/qqmlcomponent/tst_qqmlcomponent.cpp b/tests/auto/qml/qqmlcomponent/tst_qqmlcomponent.cpp
index 320344ffb6..57e63e87a7 100644
--- a/tests/auto/qml/qqmlcomponent/tst_qqmlcomponent.cpp
+++ b/tests/auto/qml/qqmlcomponent/tst_qqmlcomponent.cpp
@@ -1026,9 +1026,45 @@ struct ComponentWithPublicSetInitial : QQmlComponent
     }
 };
 
+class MyObject : public QObject
+{
+    Q_OBJECT
+    Q_PROPERTY(int resettable MEMBER m_resettable RESET resetIt NOTIFY resettableChanged)
+    void resetIt() { resetCalled = true; }
+
+public:
+    MyObject(QObject *parent = nullptr) : QObject(parent) { }
+    int m_resettable;
+    bool resetCalled = false;
+
+signals:
+    void resettableChanged();
+};
+
+
 void tst_qqmlcomponent::testSetInitialProperties()
 {
     QQmlEngine eng;
+    qmlRegisterType<MyObject>("ResetTest", 1, 0, "MyObject");
+    // reset logic
+    {
+        QQmlComponent comp(&eng);
+        comp.loadFromModule("ResetTest", "MyObject");
+        std::unique_ptr<QObject>  obj {comp.createWithInitialProperties({{u"resettable"_s, QVariant() }}) };
+        QVERIFY(obj);
+        QVERIFY(qobject_cast<MyObject *>(obj.get())->resetCalled);
+    }
+    // reset logic - null != undefined
+    {
+        QQmlComponent comp(&eng);
+        comp.loadFromModule("ResetTest", "MyObject");
+        QVariant var = QVariant::fromValue(nullptr);
+        QVERIFY(var.isNull() && var.isValid());
+        QTest::ignoreMessage(QtMsgType::QtWarningMsg, QRegularExpression(".*Could not set initial property resettable"_L1));
+        std::unique_ptr<QObject>  obj {comp.createWithInitialProperties({{u"resettable"_s, var }}) };
+        QVERIFY(obj);
+        QVERIFY(!qobject_cast<MyObject *>(obj.get())->resetCalled);
+    }
     {
         //  QVariant
         ComponentWithPublicSetInitial comp(&eng);
-- 
2.51.2

