From 3e2d26a31993e8b457bdcd9d7830c67c5ace3180 Mon Sep 17 00:00:00 2001
From: Ulf Hermann <ulf.hermann@qt.io>
Date: Thu, 16 Oct 2025 15:35:25 +0200
Subject: [PATCH 210/239] QmlModels: Always produce valid context for functions
 in ListElement

If necessary, create the inner QQmlListModel eagerly. It would otherwise
be created lazily when retrieving the function.

Pick-to: 6.8 6.5
Fixes: QTBUG-140900
Change-Id: Icf26570e7bd214c04855de1dfc22b2a6a1dae709
Reviewed-by: Sami Shalayel <sami.shalayel@qt.io>
(cherry picked from commit d51b5a1156e53859ca6a3ec4b1ad3f0844ff304c)
Reviewed-by: Qt Cherry-pick Bot <cherrypick_bot@qt-project.org>
---
 src/qmlmodels/qqmllistmodel.cpp               | 15 ++++++++---
 src/qmlmodels/qqmllistmodel_p.h               |  3 ++-
 .../qqmllistmodel/data/functionInNested.qml   | 25 +++++++++++++++++++
 .../qml/qqmllistmodel/tst_qqmllistmodel.cpp   | 13 ++++++++++
 4 files changed, 52 insertions(+), 4 deletions(-)
 create mode 100644 tests/auto/qml/qqmllistmodel/data/functionInNested.qml

diff --git a/src/qmlmodels/qqmllistmodel.cpp b/src/qmlmodels/qqmllistmodel.cpp
index b30db8aeaf..215964ebd6 100644
--- a/src/qmlmodels/qqmllistmodel.cpp
+++ b/src/qmlmodels/qqmllistmodel.cpp
@@ -2874,7 +2874,8 @@ bool QQmlListModelParser::verifyProperty(
 
 bool QQmlListModelParser::applyProperty(
         const QQmlRefPointer<QV4::ExecutableCompilationUnit> &compilationUnit,
-        const QV4::CompiledData::Binding *binding, ListModel *model, int outterElementIndex)
+        const QV4::CompiledData::Binding *binding, ListModel *model, QQmlListModel *owner,
+        int outterElementIndex)
 {
     const QString elementName = compilationUnit->stringAt(binding->propertyNameIndex);
 
@@ -2903,7 +2904,7 @@ bool QQmlListModelParser::applyProperty(
 
         const QV4::CompiledData::Binding *subBinding = target->bindingTable();
         for (quint32 i = 0; i < target->nBindings; ++i, ++subBinding) {
-            roleSet |= applyProperty(compilationUnit, subBinding, subModel, elementIndex);
+            roleSet |= applyProperty(compilationUnit, subBinding, subModel, owner, elementIndex);
         }
 
     } else {
@@ -2932,6 +2933,13 @@ bool QQmlListModelParser::applyProperty(
 
                 auto v4 = compilationUnit->engine;
                 QV4::Scope scope(v4);
+
+                if (model->m_modelCache == nullptr) {
+                    model->m_modelCache = new QQmlListModel(owner, model, v4);
+                    QQmlEngine::setContextForObject(
+                            model->m_modelCache, QQmlEngine::contextForObject(owner));
+                }
+
                 // for now we do not provide a context object; data from the ListElement must be passed to the function
                 QV4::ScopedContext context(scope, QV4::QmlContext::create(v4->rootContext(), QQmlContextData::get(qmlContext(model->m_modelCache)), nullptr));
                 QV4::ScopedFunctionObject function(scope, QV4::FunctionObject::createScriptFunction(context, compilationUnit->runtimeFunctions[id]));
@@ -2998,7 +3006,8 @@ void QQmlListModelParser::applyBindings(
     for (const QV4::CompiledData::Binding *binding : bindings) {
         if (binding->type() != QV4::CompiledData::Binding::Type_Object)
             continue;
-        setRoles |= applyProperty(compilationUnit, binding, rv->m_listModel, /*outter element index*/-1);
+        setRoles |= applyProperty(
+                compilationUnit, binding, rv->m_listModel, rv, /*outter element index*/-1);
     }
 
     if (setRoles == false)
diff --git a/src/qmlmodels/qqmllistmodel_p.h b/src/qmlmodels/qqmllistmodel_p.h
index 26ca6e7d13..f1dfcdcae1 100644
--- a/src/qmlmodels/qqmllistmodel_p.h
+++ b/src/qmlmodels/qqmllistmodel_p.h
@@ -177,7 +177,8 @@ private:
     // returns true if a role was set
     bool applyProperty(
             const QQmlRefPointer<QV4::ExecutableCompilationUnit> &compilationUnit,
-            const QV4::CompiledData::Binding *binding, ListModel *model, int outterElementIndex);
+            const QV4::CompiledData::Binding *binding, ListModel *model, QQmlListModel *owner,
+            int outterElementIndex);
 
     static bool definesEmptyList(const QString &);
 
diff --git a/tests/auto/qml/qqmllistmodel/data/functionInNested.qml b/tests/auto/qml/qqmllistmodel/data/functionInNested.qml
new file mode 100644
index 0000000000..a5781ec9b5
--- /dev/null
+++ b/tests/auto/qml/qqmllistmodel/data/functionInNested.qml
@@ -0,0 +1,25 @@
+import QtQml
+
+Instantiator {
+    model: ListModel {
+        ListElement {
+            submenu: [
+                ListElement {
+                    func : function() {
+                        console.log("called")
+                    }
+                }
+            ]
+        }
+    }
+    delegate: Instantiator {
+        required property ListModel submenu
+        model: submenu
+        delegate: QtObject {
+            required property var func
+            Component.onCompleted: {
+                func()
+            }
+        }
+    }
+}
diff --git a/tests/auto/qml/qqmllistmodel/tst_qqmllistmodel.cpp b/tests/auto/qml/qqmllistmodel/tst_qqmllistmodel.cpp
index a90847ac81..a0b55117b9 100644
--- a/tests/auto/qml/qqmllistmodel/tst_qqmllistmodel.cpp
+++ b/tests/auto/qml/qqmllistmodel/tst_qqmllistmodel.cpp
@@ -125,6 +125,7 @@ private slots:
     void deadModelData();
     void valuesOfInnerList();
     void arrayLikes();
+    void functionInNested();
 };
 
 bool tst_qqmllistmodel::compareVariantList(const QVariantList &testList, QVariant object)
@@ -2198,6 +2199,18 @@ void tst_qqmllistmodel::arrayLikes()
     QCOMPARE(o->property("s").toString(), "2t");
 }
 
+void tst_qqmllistmodel::functionInNested()
+{
+    QQmlEngine engine;
+    QQmlComponent c(&engine, testFileUrl("functionInNested.qml"));
+    QVERIFY2(c.isReady(), qPrintable(c.errorString()));
+
+    QTest::ignoreMessage(QtDebugMsg, "called");
+
+    QScopedPointer<QObject> o(c.create());
+    QVERIFY(!o.isNull());
+}
+
 QTEST_MAIN(tst_qqmllistmodel)
 
 #include "tst_qqmllistmodel.moc"
-- 
2.51.2

