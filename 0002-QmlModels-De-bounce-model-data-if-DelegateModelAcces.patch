From 4d9841d3949330f868b8d2e930cdc705729ec1d5 Mon Sep 17 00:00:00 2001
From: Ulf Hermann <ulf.hermann@qt.io>
Date: Mon, 1 Sep 2025 18:40:45 +0200
Subject: [PATCH 002/239] QmlModels: De-bounce model data if
 DelegateModelAccess:ReadWrite

The presence of two-way bindings guarantees any change to the model to
bounce back and write the model again. We generally don't want that.
Therefore, prevent it at the metaobject layer by temporarily installing
a metaobject that filters the relevant metacalls.

Amends commit 4bd5b312795024bd5bcd698525b58caf3893c913

Task-number: QTBUG-132420
Change-Id: I8a1a3aa688020fda621e8ba3dcb68a70c7b70b6a
Reviewed-by: Sami Shalayel <sami.shalayel@qt.io>
(cherry picked from commit 7873f3484c6ec8ace0dd63acaafcda7aa5fdcde0)
---
 src/qmlmodels/qqmldelegatemodel_p_p.h         | 53 +++++++++++++++++++
 src/qmlmodels/qqmldmabstractitemmodeldata_p.h | 27 ++++++----
 .../qml/qqmlrangemodel/tst_qqmlrangemodel.cpp |  2 -
 3 files changed, 71 insertions(+), 11 deletions(-)

diff --git a/src/qmlmodels/qqmldelegatemodel_p_p.h b/src/qmlmodels/qqmldelegatemodel_p_p.h
index 0191005252..20cf8f0255 100644
--- a/src/qmlmodels/qqmldelegatemodel_p_p.h
+++ b/src/qmlmodels/qqmldelegatemodel_p_p.h
@@ -143,6 +143,11 @@ public:
 
     void disableStructuredModelData() { useStructuredModelData = false; }
 
+    QDynamicMetaObjectData *exchangeMetaObject(QDynamicMetaObjectData *metaObject)
+    {
+        return std::exchange(d_ptr->metaObject, metaObject);
+    }
+
 Q_SIGNALS:
     void modelIndexChanged();
     Q_REVISION(2, 12) void rowChanged();
@@ -205,6 +210,54 @@ private:
     std::vector<PoolItem> m_reusableItemsPool;
 };
 
+template<typename Target>
+class QQmlDelegateModelReadOnlyMetaObject : QDynamicMetaObjectData
+{
+    Q_DISABLE_COPY_MOVE(QQmlDelegateModelReadOnlyMetaObject)
+
+public:
+    QQmlDelegateModelReadOnlyMetaObject(const Target &target, int readOnlyProperty)
+        : target(target)
+        , readOnlyProperty(readOnlyProperty)
+    {
+        if (QQmlDelegateModelItem *object = target)
+            original = object->exchangeMetaObject(this);
+    }
+
+    ~QQmlDelegateModelReadOnlyMetaObject()
+    {
+        if (QQmlDelegateModelItem *object = target)
+            object->exchangeMetaObject(original);
+    }
+
+    void objectDestroyed(QObject *o) final
+    {
+        if (target)
+            original->objectDestroyed(o);
+    }
+
+    QMetaObject *toDynamicMetaObject(QObject *o) final
+    {
+        return target ? original->toDynamicMetaObject(o) : nullptr;
+    }
+
+    int metaCall(QObject *o, QMetaObject::Call call, int id, void **argv) final
+    {
+        if (!target)
+            return 0;
+
+        if (id == readOnlyProperty && call == QMetaObject::WriteProperty)
+            return 0;
+
+        return original->metaCall(o, call, id, argv);
+    }
+
+private:
+    Target target = {};
+    QDynamicMetaObjectData *original = nullptr;
+    int readOnlyProperty = -1;
+};
+
 class QQmlDelegateModelPrivate;
 class QQDMIncubationTask : public QQmlIncubator
 {
diff --git a/src/qmlmodels/qqmldmabstractitemmodeldata_p.h b/src/qmlmodels/qqmldmabstractitemmodeldata_p.h
index 371aa2602d..c98b8fce6e 100644
--- a/src/qmlmodels/qqmldmabstractitemmodeldata_p.h
+++ b/src/qmlmodels/qqmldmabstractitemmodeldata_p.h
@@ -85,10 +85,19 @@ public:
     {
     }
 
-    void notifyItem(const QQmlGuard<QQmlDMAbstractItemModelData> &item, const QVector<int> &signalIndexes) const
+    void notifyItem(
+            const QQmlGuard<QQmlDMAbstractItemModelData> &item,
+            const QVector<int> &indexes,
+            QQmlDelegateModel::DelegateModelAccess access) const
     {
-        for (const int signalIndex : signalIndexes) {
-            QMetaObject::activate(item, signalIndex, nullptr);
+        for (const int index : indexes) {
+            if (access == QQmlDelegateModel::DelegateModelAccess::ReadWrite) {
+                QQmlDelegateModelReadOnlyMetaObject readOnly(item, index + propertyOffset);
+                QMetaObject::activate(item, index + signalOffset, nullptr);
+            } else {
+                QMetaObject::activate(item, index + signalOffset, nullptr);
+            }
+
             if (item.isNull())
                 return;
         }
@@ -96,7 +105,7 @@ public:
     }
 
     bool notify(
-            const QQmlAdaptorModel &,
+            const QQmlAdaptorModel &model,
             const QList<QQmlDelegateModelItem *> &items,
             int index,
             int count,
@@ -113,7 +122,7 @@ public:
             const_cast<VDMAbstractItemModelDataType *>(this)->watchedRoleIds = roleIds;
         }
 
-        QVector<int> signalIndexes;
+        QVector<int> indexes;
         for (int i = 0; i < roles.size(); ++i) {
             const int role = roles.at(i);
             if (!changed && watchedRoleIds.contains(role))
@@ -121,13 +130,13 @@ public:
 
             int propertyId = propertyRoles.indexOf(role);
             if (propertyId != -1)
-                signalIndexes.append(propertyId + signalOffset);
+                indexes.append(propertyId);
         }
         if (roles.isEmpty()) {
             const int propertyRolesCount = propertyRoles.size();
-            signalIndexes.reserve(propertyRolesCount);
+            indexes.reserve(propertyRolesCount);
             for (int propertyId = 0; propertyId < propertyRolesCount; ++propertyId)
-                signalIndexes.append(propertyId + signalOffset);
+                indexes.append(propertyId);
         }
 
         QVarLengthArray<QQmlGuard<QQmlDMAbstractItemModelData>> guardedItems;
@@ -142,7 +151,7 @@ public:
 
             const int idx = item->modelIndex();
             if (idx >= index && idx < index + count)
-                notifyItem(item, signalIndexes);
+                notifyItem(item, indexes, model.delegateModelAccess);
         }
         return changed;
     }
diff --git a/tests/auto/qml/qqmlrangemodel/tst_qqmlrangemodel.cpp b/tests/auto/qml/qqmlrangemodel/tst_qqmlrangemodel.cpp
index ad2c2abc24..49542b1ad2 100644
--- a/tests/auto/qml/qqmlrangemodel/tst_qqmlrangemodel.cpp
+++ b/tests/auto/qml/qqmlrangemodel/tst_qqmlrangemodel.cpp
@@ -354,7 +354,6 @@ void tst_QQmlRangeModel::intRange()
     const QVariant newValue = 7;
     QVERIFY(model.setData(index, newValue, Qt::RangeModelDataRole)); // default: Qt::EditRole
     // ... should give us one call to setData (our own)
-    QEXPECT_FAIL("ReadWrite", "Unexpected call to setData", Continue); // but we get two
     QCOMPARE(model.setDataCalls, QList<int>{Qt::RangeModelDataRole});
     model.setDataCalls.clear();
     // ... and results in a single call to data() to get the new value
@@ -420,7 +419,6 @@ void tst_QQmlRangeModel::objectRange()
     QCOMPARE(currentItem->property("number"), newNumber);
     QCOMPARE(currentItem->property("modelNumber"), newNumber);
     // ... and there should only be our call to setData
-    QEXPECT_FAIL("ReadWrite", "Extra call to setData()", Continue);
     QCOMPARE(model.setDataCalls, QList<int>{Entry::NumberRole});
     model.setDataCalls.clear();
     model.dataCalls.clear();
-- 
2.51.2

