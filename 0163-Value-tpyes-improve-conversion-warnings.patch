From f87c718e1e9a95835e5b9073870abd1f20210913 Mon Sep 17 00:00:00 2001
From: Fabian Kosmale <fabian.kosmale@qt.io>
Date: Thu, 18 Sep 2025 16:23:18 +0200
Subject: [PATCH 163/239] Value tpyes: improve conversion warnings

Add some information from the stacktrace, so that users can find the
offending QML line.
Moreover, use QDebug::toString instead of QVariant::toString for
stringifying variants, as the former has a higher chance of creating
some string representation.

Fixes: QTBUG-139749
Change-Id: I340d1312fcda604eb921cf289684256fc8e464d4
Reviewed-by: Ulf Hermann <ulf.hermann@qt.io>
(cherry picked from commit 61e9aa7f5795258951d39ded70f14772b6ee2381)
Reviewed-by: Qt Cherry-pick Bot <cherrypick_bot@qt-project.org>
---
 src/qml/qml/qqmlglobal.cpp                    | 33 ++++++++++++-------
 src/qml/qml/qqmlglobal_p.h                    |  2 +-
 .../data/createValueTypeErrors.qml            | 15 +++++++++
 .../tst_qqmlvaluetypeproviders.cpp            | 33 +++++++++++++++++++
 4 files changed, 70 insertions(+), 13 deletions(-)
 create mode 100644 tests/auto/qml/qqmlvaluetypeproviders/data/createValueTypeErrors.qml

diff --git a/src/qml/qml/qqmlglobal.cpp b/src/qml/qml/qqmlglobal.cpp
index be83629b37..7653e94944 100644
--- a/src/qml/qml/qqmlglobal.cpp
+++ b/src/qml/qml/qqmlglobal.cpp
@@ -15,6 +15,19 @@
 
 QT_BEGIN_NAMESPACE
 
+static void printConversionWarning(QV4::ExecutionEngine *engine, const QString &propertyValue,
+                                   const QString &propertyType, const QString &propertyName) {
+    auto stackTrace = engine->stackTrace(1);
+    QString errorLocation;
+    if (!stackTrace.isEmpty()) {
+        const auto& stackTop = stackTrace[0];
+        errorLocation = QString::fromLatin1("%1:%2: ").arg(stackTop.source, QString::number(stackTop.line));
+    }
+    qWarning().noquote()
+        << QLatin1String("%4Could not convert %1 to %2 for property %3")
+                .arg(propertyValue, propertyType, propertyName, errorLocation);
+}
+
 // Pre-filter the metatype before poking QQmlMetaType::qmlType() and locking its mutex.
 static bool isConstructibleMetaType(const QMetaType metaType)
 {
@@ -396,10 +409,8 @@ static void doWriteProperties(
             continue;
         }
 
-        qWarning().noquote()
-                << QLatin1String("Could not convert %1 to %2 for property %3")
-                   .arg(v4PropValue->toQStringNoThrow(), QString::fromUtf8(propertyType.name()),
-                        propertyName);
+        printConversionWarning(engine, v4PropValue->toQStringNoThrow(),
+                               QString::fromUtf8(propertyType.name()), propertyName);
     }
 }
 
@@ -451,10 +462,9 @@ static void doWriteProperties(
             continue;
         }
 
-        qWarning().noquote()
-            << QLatin1String("Could not convert %1 to %2 for property %3")
-                   .arg(property.toString(), QString::fromUtf8(propertyType.name()),
-                        QString::fromUtf8(metaProperty.name()));
+        printConversionWarning(engine, QDebug::toString(property),
+                               QString::fromUtf8(propertyType.name()),
+                               QString::fromUtf8(metaProperty.name()));
     }
 }
 
@@ -532,10 +542,9 @@ void doWriteProperties(
             continue;
         }
 
-        qWarning().noquote()
-            << QLatin1String("Could not convert %1 to %2 for property %3")
-                   .arg(property.toString(), QString::fromUtf8(propertyType.name()),
-                        QString::fromUtf8(metaProperty.name()));
+        printConversionWarning(engine, QDebug::toString(property),
+                               QString::fromUtf8(propertyType.name()),
+                               QString::fromUtf8(metaProperty.name()));
     }
 }
 
diff --git a/src/qml/qml/qqmlglobal_p.h b/src/qml/qml/qqmlglobal_p.h
index cd7250c30a..710a5ef3f8 100644
--- a/src/qml/qml/qqmlglobal_p.h
+++ b/src/qml/qml/qqmlglobal_p.h
@@ -222,7 +222,7 @@ public:
     static QVariant createValueType(const QJSValue &, QMetaType);
     static QVariant createValueType(const QString &, QMetaType);
     static QVariant createValueType(const QV4::Value &, QMetaType, QV4::ExecutionEngine *);
-    static QVariant createValueType(const QVariant &, QMetaType, QV4::ExecutionEngine *);
+    static QVariant Q_AUTOTEST_EXPORT createValueType(const QVariant &, QMetaType, QV4::ExecutionEngine *);
 };
 
 class Q_QML_EXPORT QQmlColorProvider
diff --git a/tests/auto/qml/qqmlvaluetypeproviders/data/createValueTypeErrors.qml b/tests/auto/qml/qqmlvaluetypeproviders/data/createValueTypeErrors.qml
new file mode 100644
index 0000000000..1f4d1266f6
--- /dev/null
+++ b/tests/auto/qml/qqmlvaluetypeproviders/data/createValueTypeErrors.qml
@@ -0,0 +1,15 @@
+// only used to ensure that we have a stack frame which can be used for reporting
+import QtQml
+import Test
+
+QtObject {
+   id: root
+   required property QtObject runner
+   property structured b2
+   property rect r
+
+   Component.onCompleted: {
+      runner.incompatibleStructuredValue()
+      b2 = {i: root.r }
+   }
+}
diff --git a/tests/auto/qml/qqmlvaluetypeproviders/tst_qqmlvaluetypeproviders.cpp b/tests/auto/qml/qqmlvaluetypeproviders/tst_qqmlvaluetypeproviders.cpp
index 936b0ac14c..a82c608967 100644
--- a/tests/auto/qml/qqmlvaluetypeproviders/tst_qqmlvaluetypeproviders.cpp
+++ b/tests/auto/qml/qqmlvaluetypeproviders/tst_qqmlvaluetypeproviders.cpp
@@ -35,6 +35,9 @@ class tst_qqmlvaluetypeproviders : public QQmlDataTest
 public:
     tst_qqmlvaluetypeproviders() : QQmlDataTest(QT_QMLTEST_DATADIR) {}
 
+public:
+    Q_INVOKABLE void incompatibleStructuredValue();
+
 private slots:
     void initTestCase() override;
 
@@ -51,6 +54,10 @@ private slots:
     void date();
     void constructors();
     void constructFromJSValue();
+    void createValueTypeErrors();
+
+private:
+    QQmlEngine *m_engine = nullptr;
 };
 
 void tst_qqmlvaluetypeproviders::initTestCase()
@@ -613,6 +620,32 @@ void tst_qqmlvaluetypeproviders::constructFromJSValue()
     QCOMPARE(fromJSManaged.value<FromJSManaged>().toString(), QStringLiteral("bbbb"));
 }
 
+void tst_qqmlvaluetypeproviders::incompatibleStructuredValue()
+{
+    QMetaType structuredValueTypeType = QMetaType::fromType<StructuredValueType>();
+    QVariantMap m;
+    m.insert(QLatin1String("i"), QVariant::fromValue(m_engine));
+    QVariant source = QVariant::fromValue(std::move(m));
+    QQmlValueTypeProvider::createValueType(source, structuredValueTypeType, m_engine->handle());
+}
+
+void tst_qqmlvaluetypeproviders::createValueTypeErrors()
+{
+    QQmlEngine engine;
+    m_engine = &engine;
+    auto url = testFileUrl("createValueTypeErrors.qml");
+    QTest::ignoreMessage(QtWarningMsg, QRegularExpression(url.toString()
+        + u":\\d+: Could not convert QVariant\\(QQmlEngine.*\\) to int for property i"
+    ));
+    QTest::ignoreMessage(QtWarningMsg, QRegularExpression(url.toString()
+        + u":\\d+: Could not convert QRectF\\(0, 0, 0, 0\\) to int for property i"
+    ));
+    QQmlComponent comp(&engine, url);
+    std::unique_ptr<QObject> rooot(comp.createWithInitialProperties(
+        {{QLatin1String("runner"), QVariant::fromValue(this)}}
+    ));
+}
+
 QTEST_MAIN(tst_qqmlvaluetypeproviders)
 
 #include "tst_qqmlvaluetypeproviders.moc"
-- 
2.51.2

